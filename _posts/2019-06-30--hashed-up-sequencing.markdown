---
layout: post
title: Hashed up Sequencing – Perl weekly challenge, week 14
date: '2019-06-30T13:13:30.000+10:00'
author: Francis
tags:
- perlweeklychallenge
- perl6
modified_time: '2019-06-30T15:34:54.000+10:00'
utterances: true
---

It's been 4 weeks; well past time to blog again; this time for [Perl Weekly
Challenge 014](https://perlweeklychallenge.org/blog/perl-weekly-challenge-010/)

## What the Van Eck?

The first challenge for me this week was to go to the Wikipedia page, read what
it was saying, and try to figure out exactly what the Van Eck sequence is.

This was at 10pm and I'd spent all day learning to adapt to Fedora afer
installing that on my new laptop (and discovering while trying to attach a
NASalike via SSH to my existing workstation that I'd set up SSH to immediately
launch a docker container that sandboxed my user into my home directory, thus
causing nothing to work as expected). After some heavy screen glaring I managed
to arrive at a re-interpretation as three rules:

* *a*<sub>0</sub> = 0
* *a*<sub>*n* + 1</sub> = *a*<sub>*n*</sub> - *a*<sub>*m*</sub> when *m* is
  the largest index < *n* of *a* having *a*<sub>*m*</sub> = *a*<sub>*n*</sub>
* *a*<sub>*n* + 1</sub> = 0 when the conditions for *m* cannot be met.

This was sufficient for me to then confuse myself into tyring to store the next
*m* and *n* pair for a given value of *a* in a hash and fill everything up with
0 in a gather / take loop.

I did a lot of filling everything up with 0.

I replaced this first implementation (sorry, I didn't save this source so you
could all laugh at it) with an eager list generation that would count back from
the current *n* to 0 instead:

{% highlight perl -%}
my $m = Van_Eck[max(0, $n-1)...0]:k.first({Van_Eck[$_] == Van_Eck[$n]});
take defined($m) ?? $n - $m !! 0;
{%- endhighlight %}

This works, but is quite slow, probably mainly because of the eager list
generation. A keen observer might also notice that `Van_Eck[max(0, $n-1)...0]:k`
is a bit silly, given that getting the keys of a list that you've generated by
specifying the keys of another list is just going to give you the same list
you've specified back, so I may as well have written `(max(0, $n-1)...0)`, but I
went to bed and discovered this the next morning instead, laughed out loud, and
fixed it; my 7 year old daughter also thought it funny.

This didn't solve the speed issue though (even if said problem was only
noticeable when you gave the program an obscene upper bound), so I revisited
using a hash to find the highest index the same as *a<sub>n</sub>* and the
sleep-having version of myself quickly realised that I only needed to store one
index per hash element, and whether such an *m* existed could be determined
using the `:exists` adverb.

After a little bit of failing to realise I never needed to explicitly update
`%m{0}` (and thus filling everything up with 0 again) I finally managed to come
up with something that wouldn't stall massively when asked to find 2000 elements
in the sequence:

{% highlight perl -%}
my \Van_Eck := gather {
  take $start;
  my %m = $start => 0;
  
  for ^∞ -> $n {
    take %m{Van_Eck[$n]}:exists ?? $n - %m{Van_Eck[$n]} !! 0;
    %m{Van_Eck[$n]} = $n;
  }
}
{%- endhighlight %}

Worth noting is that `$n` is always one behind the index of the current value
being taken.

[Github link to solution](https://github.com/fjwhittle/perlweeklychallenge-club/blob/master/challenge-014/fjwhittle/perl6/ch-1.p6)

## Spelling with the United States

Perl 6 makes the meat of this almost trivial. Create a set of the states'
abbreviations (I zipped these into a hash of the states' names for later
reference), sort all the even length words you have (e.g.
`/usr/share/dict/words`) into longest to shortest order, then find the first list
element where a comb of 2-letter sequences of the word is a subset of the
abbreviations.

Using the hash of abbreviation => name I then print out which states spelt the
word and the word itself.

Apparently, the longest spellable word in the British English dictionary on my
system is cacogalactia, which apparently means that California, Colorado,
Georgia, Louisiana, Connecticut & Iowa are together [states of bad
milk](https://www.wordnik.com/words/cacogalactia)...

[Github link to solution](https://github.com/fjwhittle/perlweeklychallenge-club/blob/master/challenge-014/fjwhittle/perl6/ch-2.p6)
